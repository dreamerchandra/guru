import Defer from "../defer";
import { getCurrentUser } from "../firebase-auth";
import { convertImgToDownloadPath, getDataFromQuerySnapShot, getServerTimeStamp, ref, storageRef } from "../firebase-helper";
import { InternalError, parseAutoGeneratedError } from "../helper";
import Paginate from "../pagenate";


window.getCurrentUser = getCurrentUser;

function isNotValidChapter (chapter) {
  if (
    // chapter.createdBy
    typeof chapter.createdBy !== 'string' ||
    chapter.createdBy.length >= 86 ||
    chapter.createdBy === ''
  ) {
    return 'error in chapter.createdBy';
  } else if (
    // chapter.createdAt
    typeof chapter.createdAt !== 'object' ||
    chapter.createdAt === ''
  ) {
    return 'error in chapter.createdAt';
  } else if (
    // chapter.lastModifiedAt
    typeof chapter.lastModifiedAt !== 'object' ||
    chapter.lastModifiedAt === ''
  ) {
    return 'error in chapter.lastModifiedAt';
  } else if (
    // chapter.title
    typeof chapter.title !== 'string' ||
    chapter.title.length < 4 ||
    chapter.title.length > 50
  ) {
    return 'error in chapter.title';
  } else if (
    // chapter.tag
    !Array.isArray(chapter.tag)
  ) {
    return 'error in chapter.tag';
  } else if (
    // chapter.titleImg
    typeof chapter.titleImg !== 'string' ||
    chapter.titleImg.length >= 200
  ) {
    return 'error in chapter.titleImg';
  } else if (
    // chapter.category
    !Array.isArray(chapter.category)
  ) {
    return 'error in chapter.category';
  } else if (
    // chapter.folders
    !Array.isArray(chapter.folders)
  ) {
    return 'error in chapter.folders';
  } else if (
    // chapter.keywords
    !Array.isArray(chapter.keywords)
  ) {
    return 'error in chapter.keywords';
  } else return false;
}


const createKeywordsFromString = (givenWord = '') => { // word = "Hello World"

  const toKeyword = (keywords, letter) => {
    const newWord = keywords[keywords.length - 1] + letter;
    return [...keywords, newWord];
  }

  const word = givenWord.toLocaleLowerCase().split(' ').join(''); // ""helloworld"
  const keyword = word.split('').reduce(toKeyword, [''])
  const searchTerm = keyword.filter((word) => word.length >= 3);
  const uniqueSearchTerm = [...new Set(searchTerm)];
  return uniqueSearchTerm;
}

const createKeywordForChapter = (title, tags, categories) => {
  const keywordForTag = tags.reduce((pre, tag) => {
    return [...pre, ...createKeywordsFromString(tag)]
  }, []);
  const keywordForCategory = categories.map(({ id }) => id);

  const searchTerm = [
    ...createKeywordsFromString(title),
    ...keywordForTag,
    ...keywordForCategory
  ]

  const uniqueSearchTerm = [...new Set(searchTerm)];
  return uniqueSearchTerm;
}

function addMetaToPayload (payload) {
  const { tag, category, title } = payload;
  return {
    ...payload,
    keywords: createKeywordForChapter(title, tag, category),
    lastModifiedAt: getServerTimeStamp(),
    createdBy: getCurrentUser(),
  }
}

const paginate = new Paginate('my.chapter');
export { paginate as chapterPaginate };

const uploadFile = async (id, file) => {
  const bucketRef = storageRef(`${id}/original`).chapter;
  return {
    task: bucketRef.put(file),
    fullPath: bucketRef.fullPath,
  }
}

const sanitizeData = (data) => {
  return {
    ...data,
    folders: data.folders.map(folder => folder.id)
  }
}

export default function chapterApi (http, baseUrl, responseWrapper) {
  return {

    create: async (payload) => {
      const data = { ...payload, titleImg: '', batches: { [getCurrentUser()]: true } }
      const chapter = { ...addMetaToPayload(sanitizeData(data)), createdAt: getServerTimeStamp() };

      const error = parseAutoGeneratedError(isNotValidChapter(chapter))
      if (error) {
        throw new InternalError('Invalid Payload', error)
      }

      const newDoc = ref().chapter.doc();

      const { fullPath, task } = await uploadFile(newDoc.id, payload.titleImg.files[0]);
      console.log(fullPath)
      const uploadPromise = new Defer()
      task.then(uploadPromise.resolve);

      return Promise.all([
        newDoc.set({ ...chapter, titleImg: fullPath }),
        uploadPromise
      ]);
    },

    getMine: async (pageSize) => {
      const snap = await ref().chapter
        .where('createdBy', '==', getCurrentUser())
        .orderBy('lastModifiedAt', 'desc').limit(100).get()
      // const snap = await paginate.getNextPage(query, pageSize) // too many places to fix
      return Promise.all(getDataFromQuerySnapShot('id', snap).map(convertImgToDownloadPath()));
    },

    getBy: async ({ folderId, search = '' }) => {
      let query = ref().chapter;
      if (folderId) {
        query = query.where('folders', 'array-contains', folderId).where(`batches.${getCurrentUser()}`, '==', true)
      }
      else if (search.length > 3) {
        query = query.where('keywords', 'array-contains', search).where(`batches.${getCurrentUser()}`, '==', true)
      } else {
        return []
      }
      const snap = await query.orderBy('lastModifiedAt', 'desc').get()
      return Promise.all(getDataFromQuerySnapShot('id', snap).map(convertImgToDownloadPath()));
    }

  }
}